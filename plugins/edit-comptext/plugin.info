{
    "author": "AlainD",
    "core-version": "< 5.1.23",
    "description": "For Testing Only - Editor with some on-line completion capabilities",
    "list": "readme usage examples",
    "name": "Test version",
    "plugin-type": "plugin",
    "source": "https://github.com/snowgoon88/TW5-extendedit",
    "title": "$:/plugins/snowgoon88/edit-comptext",
    "type": "application/json",
    "version": "0.9.7-test.streams",
    "tiddlers": {
        "$:/plugins/snowgoon88/edit-comptext/config": {
            "title": "$:/plugins/snowgoon88/edit-comptext/config",
            "type": "application/json",
            "text": "{\n  \"configuration\": {\n      \"caseSensitive\" : false,\n      \"maxMatch\" : 8,\n      \"minPatLength\" : 2,\n      \"triggerKeyCombination\" : \"^ \"\n  },\n  \"template\": [{\n      \"pattern\": \"[[\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n      },\n      {\n      \"pattern\": \"||\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[|\",\n      \"end\": \"]]\",\n      \"startOffset\" : 2\n      }\n  ]\n}\n"
        },
        "$:/plugins/snowgoon88/edit-comptext/edit-comptext.js": {
            "title": "$:/plugins/snowgoon88/edit-comptext/edit-comptext.js",
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/edit-comptext.js\ntype: application/javascript\nmodule-type: widget\n\nTaken from original Edit-text widget\nVersion 5.1.13 of TW5\nAdd link-to-tiddler completion in framed.js and simple.js\n\nTODO : CHECK usefull, and particularly save_changes after every input ??\nTODO : where should popupNode be created in the DOM ?\nTODO : check that options are valid (numeric ?)\nvar isNumeric = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar editTextWidgetFactory = require(\"$:/core/modules/editor/factory.js\").editTextWidgetFactory,\n\tFramedCompEngine = require(\"$:/plugins/snowgoon88/edit-comptext/framed.js\").FramedCompEngine,\n\tSimpleCompEngine = require(\"$:/plugins/snowgoon88/edit-comptext/simple.js\").SimpleCompEngine;\n\nexports[\"edit-comptext\"] = editTextWidgetFactory(FramedCompEngine,SimpleCompEngine);\n\n})();\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/snowgoon88/edit-comptext/examples": {
            "title": "$:/plugins/snowgoon88/edit-comptext/examples",
            "text": "The configuration file [[$:/plugins/snowgoon88/edit-comptext/config]] allow you to use the completion plugin for various usages. Here are some examples...\n\n!! Link Completion\nThe basic and default usage. Completion is triggered by `[[`, the search is among all non-system tiddlers. When selected, the `title` of the tiddler is inserted in the text, surrounded by `[[` and `]]`. This gives the following Completion Template.\n\n\n```\n{\n      \"pattern\": \"[[\",\n      \"title\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n}\t     \n```\n\n!! Link Completion and reposition to add Alias\nAnother basic usage. Completion is triggered by `||`, the search is among all non-system tiddlers. When selected, the `title` of the tiddler is inserted in the text, surrounded by `[[|` and `]]`. The cursor is positionned just before the `|`, ready for typing an Alias.\n\n```\n{\n      \"pattern\": \"||\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[|\",\n      \"end\": \"]]\",\n      \"startOffset\" : 2\n      }\n\n```\n\n!! Special macro completion\nI have a 'pnjin' macro that is invoked by `<<pnjin \"TiddlerPNJName\">>` where 'TiddlerPNJName is a tiddler that hold data about a PNJ. I use tiddlywiki to organise my Role Playing Games campaigns. So, I want `<p` to trigger the completion. The search is among all non-system tiddlers tagged `PNJ` and, once selected, the title of the tiddler must be inserted surrouned by `<<pnjin \\\"` and `\\\">>`. So...\n\n```\n{\n\t\"pattern\": \"<p\",\n      \t\"title\": \"[tag[PNJ]!is[system]]\",\n      \t\"start\": \"<<pnjin  \\\"\",\n      \t\"end\": \"\\\">>\"\n}\n```\n\n!! Insert some templates or stamp or snippets into text.\nI frequently use some text pattern and I want to insert them easily. So, I could create several tiddlers, tagged '$:stamp' and in their body are the piece of texte I want to insert. The titles of these tiddlers always start with `$:/config/stamp/` (i.e. $:/config/stamp/macro, $:/config/stamp/list1, $:/config/stamp/list2). I want to trigger the completion by using `<<`, then I only want to chose among the last part of the titles of tiddlers tagged `$:stamp` so I use a mask (`$:/config/stamp/`) to only display the last part of the tiddlers title. When selectected, the `body` of the tiddler is inserted, with no surrounding strings. As a results, the Completion Template is (notice the `body` field):\n\n```\n{\n      \"pattern\": \"<<\",\n      \"body\": \"[tag[$:stamp]]\",\n      \"mask\" : \"$:/config/stamp/\",\n      \"start\": \"\",\n      \"end\": \"\"\n}\n```\n\n!! And you ?\nIf you have funny usages of completion, let me know. If you'd like to do something that is not yet possible, let me know...\n\nmail : snowgoon88(AT)gmail(DOT)com"
        },
        "$:/plugins/snowgoon88/edit-comptext/framed.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/framed.js\ntype: application/javascript\nmodule-type: library\n\nTaken from $:/core/modules/editor/engines/framed.js\nText editor engine based on a simple input or textarea within an iframe. This is done so that the selection is preserved even when clicking away from the textarea\n\n\\*/\n(function(){\n\n/*jslint node: true,browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar HEIGHT_VALUE_TITLE = \"$:/config/TextEditor/EditorHeight/Height\";\n\n// Configuration tiddler\nvar COMPLETION_OPTIONS = \"$:/plugins/snowgoon88/edit-comptext/config\";\nvar Completion = require(\"$:/plugins/snowgoon88/edit-comptext/completion.js\").Completion;\nvar FramedEngine = require(\"$:/core/modules/editor/engines/framed.js\").FramedEngine;\n\t\nfunction FramedCompEngine(options) {\n\tFramedEngine.call(this,options);\n\tthis._configOptions = $tw.wiki.getTiddlerData( COMPLETION_OPTIONS, {} );\n\tthis._completion = new Completion( this.widget, this.domNode, this._configOptions, this.dummyTextArea, this.iframeNode.offsetTop, this.iframeNode.offsetLeft );\n};\n\nFramedCompEngine.prototype = Object.create(FramedEngine.prototype);\n\nFramedCompEngine.prototype.constructor = FramedCompEngine;\n\nexports.FramedCompEngine = FramedCompEngine;\n$tw.modules.types.library[\"$:/core/modules/editor/engines/framed.js\"].exports.FramedEngine = FramedCompEngine;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/framed.js",
            "module-type": "startup",
            "modified": "20200918093221063",
            "created": "20200918093023095"
        },
        "$:/plugins/snowgoon88/edit-comptext/simple.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/simple.js\ntype: application/javascript\nmodule-type: library\n\nTaken from $:/core/modules/editor/engines/simple.js\nText editor engine based on a simple input or textarea tag\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar HEIGHT_VALUE_TITLE = \"$:/config/TextEditor/EditorHeight/Height\";\n\n// Configuration tiddler\nvar COMPLETION_OPTIONS = \"$:/plugins/snowgoon88/edit-comptext/config\";\nvar Completion = require(\"$:/plugins/snowgoon88/edit-comptext/completion.js\").Completion;\nvar SimpleEngine = require(\"$:/core/modules/editor/engines/simple.js\").SimpleEngine;\n\t\nfunction SimpleCompEngine(options) {\n\tSimpleEngine.call(this,options);\n\tthis._configOptions = $tw.wiki.getTiddlerData( COMPLETION_OPTIONS, {} );\n\tthis._completion = new Completion( this.widget, this.domNode, this._configOptions );\n};\n\nSimpleCompEngine.prototype = Object.create(SimpleEngine.prototype);\n\nSimpleCompEngine.prototype.constructor = SimpleCompEngine;\n\n\nexports.SimpleCompEngine = SimpleCompEngine;\n$tw.modules.types.library[\"$:/core/modules/editor/engines/simple.js\"].exports.SimpleEngine = SimpleCompEngine;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/simple.js",
            "module-type": "startup",
            "modified": "20200918093543982",
            "created": "20200918093336680"
        },
        "$:/plugins/snowgoon88/edit-comptext/cursor-position.js": {
            "text": "/*\\\nModule that compute the pixel position of the cursor of a text\nements.\n\nTaken from https://github.com/component/textarea-caret-position\n\n(as https://github.com/kir/js_cursor_position is not updated any more)\n\\*/\n// Fonction anonyme executée immediatement\n( function(){\n \n// The properties that we copy into a mirrored div.\n// Note that some browsers, such as Firefox,\n// do not concatenate properties, i.e. padding-top, bottom etc. -> padding,\n// so we have to do every single property specifically.\nvar properties = [\n  'direction',  // RTL support\n  'boxSizing',\n  'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY',  // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration',  // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize'\n\n];\nvar isFirefox = false;\nif($tw.browser) {\n    isFirefox = window.mozInnerScreenX != null;\n}\n\nfunction getCaretCoordinates(element, position, options) {\n\n  var debug = options && options.debug || false;\n  if (debug) {\n    var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n    if ( el ) { el.parentNode.removeChild(el); }\n  }\n\n  // mirrored div\n  var div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  var style = div.style;\n  var computed;\n  if($tw.browser) {\n      computed = window.getComputedStyle? getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\n  } \n  else {\n      computed = element.currentStyle;\n  }\n    \n\n  // default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (element.nodeName !== 'INPUT')\n    style.wordWrap = 'break-word';  // only for textarea-s\n\n  // position off-screen\n  style.position = 'absolute';  // required to return coordinates properly\n  if (!debug)\n    style.visibility = 'hidden';  // not 'display: none' because we want rendering\n\n  // transfer the element's properties to the div\n  properties.forEach(function (prop) {\n    style[prop] = computed[prop];\n  });\n\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height))\n      style.overflowY = 'scroll';\n  } else {\n    style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, position);\n  // the second special handling for input type=\"text\" vs textarea: spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n  if (element.nodeName === 'INPUT')\n    div.textContent = div.textContent.replace(/\\s/g, \"\\u00a0\");\n\n  var span = document.createElement('span');\n  // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // for inputs, just '.' would be enough, but why bother?\n  span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\n  div.appendChild(span);\n\n  var coordinates = {\n    top: span.offsetTop + parseInt(computed['borderTopWidth']),\n    left: span.offsetLeft + parseInt(computed['borderLeftWidth'])\n  };\n\n  if (debug) {\n    span.style.backgroundColor = '#aaa';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\n// Exporte as a module of node.js otherwise set as global\nif (typeof module != \"undefined\" && typeof module.exports != \"undefined\") {\n  module.exports = getCaretCoordinates;\n} else {\n  window.getCaretCoordinates = getCaretCoordinates;\n}\n\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/cursor-position.js",
            "module-type": "library"
        },
        "$:/plugins/snowgoon88/edit-comptext/completion.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/completion.js\ntype: application/javascript\nmodule-type: library\n\nTry to make self-contained completion module.\n\nTo use this 'module', you need a `widget` with a kind of `editarea` node.\nI do not know the exacte prerequisites of this editarea node for the module to\nwork, but mostly one should be able to attach the following `eventHandler` to\nit:\n - input\n - keydown\n - keypress\n - keyup\nThe `widget` is needed because I use:\n - widget.document\n - widget.wiki.filterTiddlers(...)\n\nFrom the Widget, once you have a proper editarea, you just have to call\n - var completion = new Completion( theWidget, theEditAreaNode, configObject);\nwhere `configObject` is expected to have the following fields. if a field is missing, a default value will be given.\nOne can have many `elements' in the template array.\n\n{\n  \"configuration\": {\n      \"caseSensitive\" : false,\n      \"maxMatch\" : 8,\n      \"minPatLength\" : 2,\n      \"triggerKeyCombination\" : \"^ \"\n  },\n  \"template\": [{\n      \"pattern\": \"[[\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n      }\n  ]\n}\n\nTODO : CHECK if needed\n\\*/\n(function() {\n\n\t/*jslint node: true, browser: true */\n\t/*global $tw: false */\n\t\"use strict\";\n\n\t// To compute pixel coordinates of cursor\n\tvar getCaretCoordinates = require(\"$:/plugins/snowgoon88/edit-comptext/cursor-position.js\");\n\n\t/** Default Completion Attributes */\n\tvar DEFATT = {\n\t\tmaxMatch: 5,\n\t\tminPatLength: 2,\n\t\tcaseSensitive: false,\n\t\ttriggerKeyCombination: \"^ \"\n\t};\n\n\t/** \n\t * Struct for generic Completion Templates.\n\t * <ul>\n\t * <li>pat : pattern searched for.</li>\n\t * <li>filter : filter operation used to find the list of completion options</li>\n\t * <li>mask: replaced by \"\" when presenting completion options</li>\n\t * </ul>\n\t */\n\tvar Template = function(pat, filter, mask, field, start, end, startOffset) {\n\t\tthis.pat = pat;\n\t\tthis.filter = filter;\n\t\tthis.mask = \"^\" + regExpEscape(mask);\n\t\tthis.field = field;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.pos = 0;\n\t\tthis.startOffset = startOffset;\n\t};\n\t/**\n\t * Struct for storing completion options, as we need to memorise \n\t * the titles of the tiddlers when masked and when body must be displayed.\n\t */\n\tvar OptCompletion = function(title, str) {\n\t\tthis.title = title;\n\t\tthis.str = str;\n\t};\n\n\tvar keyMatchGenerator = function(combination) {\n\t\tlet singleMatchGenerator = function(character) {\n\t\t\tif (character === '^') {\n\t\t\t\treturn event => event.ctrlKey;\n\t\t\t} else if (character === '+') {\n\t\t\t\treturn event => event.shiftKey;\n\t\t\t} else if (character === '!') {\n\t\t\t\treturn event => event.altKey;\n\t\t\t} else {\n\t\t\t\treturn event => (event.keyCode || event.which) === character.charCodeAt(0);\n\t\t\t}\n\t\t};\n\n\t\tlet matchers = [];\n\t\tfor (let i = 0; i < combination.length; i++) {\n\t\t\tmatchers.push(singleMatchGenerator(combination[i]));\n\t\t}\n\n\t\treturn event => {\n\t\t\tfor (let i = 0; i < matchers.length; i++) {\n\t\t\t\tif (!matchers[i](event)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t};\n/*\n\t\tvar ew = require(\"$:/core/modules/editor/factory.js\").editTextWidgetFactory;\n\t\tvar old_ew_handleKeyDownEvent = ew.handleKeydownEvent;\n\t\tew.handleKeydownEvent = function(event) {\n\t\t\treturn false;\n\t\t};\n*/\n\n\t/**\n\t * Widget is needed in creating popupNode.\n\t * - widget.document\n\t * - widget.wiki.filterTiddlers(...)\n\t * - sibling : where to create the popup in the DOM.\n\t */\n\tvar Completion = function(editWidget, areaNode, param, sibling, offTop, offLeft, handler) {\n\t\tconsole.log(\"==Completion::creation\");\n\t\tthis._handler = handler;\n\t\t// About underlying Widget\n\nif(typeof sibling !== 'undefined') {\n            editWidget._old_handler = editWidget.handleKeydownEvent;\n            editWidget.handleKeydownEvent = function(event) {\n                return false;\n            }\n}\n\t\tthis._widget = editWidget;\n\t\tthis._areaNode = areaNode;\n\t\tthis._sibling = (typeof sibling !== 'undefined') ? sibling : this._areaNode;\n\t\tthis._offTop = (typeof offTop !== 'undefined') ? offTop : 0;\n\t\tthis._offLeft = (typeof offLeft !== 'undefined') ? offLeft : 0;\n\n\t\t// Completions attributes\n\t\t/** State */\n\t\tthis._state = \"VOID\";\n\t\tthis._template = undefined;\n\t\t/** Best matches */\n\t\tthis._bestMatches = []; // An array of OptCompletion\n\t\tthis._idxChoice = -1;\n\t\t/** Param */\n\t\t// maximum nb of match displayed\n\t\tthis._maxMatch = param.configuration.maxMatch || DEFATT.maxMatch;\n\t\tthis._minPatLength = param.configuration.minPatLength || DEFATT.minPatLength;\n\t\tthis._caseSensitive = param.configuration.caseSensitive || DEFATT.caseSensitive;\n\t\tthis._triggerKeyMatcher = keyMatchGenerator(param.configuration.triggerKeyCombination || DEFATT.triggerKeyCombination);\n\t\t/** Input information */\n\t\tthis._lastChar = \"\";\n\t\tthis._hasInput = false;\n\t\t/** List of Completion Templates */\n\t\tthis._listTemp = [];\n\n\t\t// Read templates from Param\n\t\tif (param.template) {\n\t\t\tvar idT;\n\t\t\tfor (idT = 0; idT < param.template.length; idT++) {\n\t\t\t\tvar temp = param.template[idT];\n\t\t\t\t// field 'body' ou 'title' (default)\n\t\t\t\tif (temp.body) {\n\t\t\t\t\tthis._listTemp.push(\n\t\t\t\t\t\tnew Template(temp.pattern, temp.body,\n\t\t\t\t\t\t\ttemp.mask ? temp.mask : \"\",\n\t\t\t\t\t\t\t\"body\",\n\t\t\t\t\t\t\ttemp.start, temp.end,\n\t\t\t\t\t\t\ttemp.startOffset)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._listTemp.push(\n\t\t\t\t\t\tnew Template(temp.pattern,\n\t\t\t\t\t\t\ttemp.title ? temp.title : temp.filter,\n\t\t\t\t\t\t\ttemp.mask ? temp.mask : \"\",\n\t\t\t\t\t\t\t\"title\",\n\t\t\t\t\t\t\ttemp.start, temp.end,\n\t\t\t\t\t\t\ttemp.startOffset)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t//DEBUG temp = this._listTemp[this._listTemp.length-1];\n\t\t\t\t//DEBUG console.log( \"__CONF : \"+temp.pattern+\":\"+temp.filter+\":\"+temp.mask+\":\"+temp.field+\":\"+temp.start+\":\"+temp.end );\n\t\t\t}\n\t\t}\n\t\t// or defaut template\n\t\telse {\n\t\t\tthis._listTemp = [\n\t\t\t\tnew Template(\"[[\", \"[all[tiddlers]!is[system]]\",\n\t\t\t\t\t\"\", \"title\",\n\t\t\t\t\t\"[[\", \"]]\")\n\t\t\t];\n\t\t}\n\t\t// Create Popup\n\t\t//this._popNode = createPopup(this._widget, this._areaNode );\n\t\tthis._popNode = createPopup(this._widget, this._sibling);\n\n\t\t// Listen to the Keyboard\n\t\t$tw.utils.addEventListeners(this._areaNode, [{\n\t\t\t\tname: \"input\",\n\t\t\t\thandlerObject: this,\n\t\t\t\thandlerMethod: \"handleInput\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"keydown\",\n\t\t\t\thandlerObject: this,\n\t\t\t\thandlerMethod: \"handleKeydown\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"keypress\",\n\t\t\t\thandlerObject: this,\n\t\t\t\thandlerMethod: \"handleKeypress\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"keyup\",\n\t\t\t\thandlerObject: this,\n\t\t\t\thandlerMethod: \"handleKeyup\"\n\t\t\t}\n\t\t]);\n\n\t\t/** \n\t\t * Find the bestMatches among listChoice with given pattern\n\t\t * @param listChoice : array of String\n\t\t * @change : this._bestMatches => array of OptCompletion\n\t\t */\n\t\tthis._findBestMatches = function(listChoice, pattern, nbMax) {\n\t\t\t// regexp search pattern, case sensitive\n\t\t\tvar flagSearch = this._caseSensitive ? \"\" : \"i\";\n\t\t\tvar regpat = RegExp(regExpEscape(pattern), flagSearch);\n\t\t\tvar regpat_start = RegExp(\"^\" + regExpEscape(pattern), flagSearch);\n\t\t\tvar regMask = RegExp(this._template.mask ? this._template.mask : \"\", \"\");\n\t\t\tvar nbMatch = 0;\n\t\t\t// nbMax set to _maxMatch if no value given\n\t\t\tnbMax = nbMax !== undefined ? nbMax : this._maxMatch;\n\n\t\t\t//DEBUG console.log( \"__FIND masked=\"+regMask+\" regPat=\"+regpat);\n\n\t\t\tthis._bestMatches = [];\n\t\t\tvar otherMatches = [];\n\t\t\t// We test every possible choice\n\t\t\tfor (var i = 0; i < listChoice.length; i++) {\n\t\t\t\t// apply mask over potential choice\n\t\t\t\tvar maskedChoice = listChoice[i].replace(regMask, \"\");\n\t\t\t\t// Test first if pattern is found at START of the maskedChoice\n\t\t\t\t// THEN added to BestMatches\n\t\t\t\tif (regpat_start.test(maskedChoice)) {\n\t\t\t\t\tif (nbMatch >= nbMax) {\n\t\t\t\t\t\tthis._bestMatches.push(new OptCompletion(\"\", \"...\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._bestMatches.push(new OptCompletion(listChoice[i], maskedChoice));\n\t\t\t\t\t\tnbMatch += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// then if pattern is found WITHIN the maskedChoice\n\t\t\t\t// added AFTER the choices that starts with pattern\n\t\t\t\telse if (regpat.test(maskedChoice)) {\n\t\t\t\t\tif (nbMatch >= nbMax) {\n\t\t\t\t\t\t// add all otherMatches to _bestMatches\n\t\t\t\t\t\tthis._bestMatches.push(new OptCompletion(\"\", \"<hr>\")); //separator\n\t\t\t\t\t\tthis._bestMatches = this._bestMatches.concat(otherMatches);\n\t\t\t\t\t\tthis._bestMatches.push(new OptCompletion(\"\", \"...\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\totherMatches.push(new OptCompletion(listChoice[i], maskedChoice));\n\t\t\t\t\t\tnbMatch += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Here, must add the otherMatches\n\t\t\tthis._bestMatches.push(new OptCompletion(\"\", \"<hr>\")); //separator\n\t\t\tthis._bestMatches = this._bestMatches.concat(otherMatches);\n\t\t};\n\t\t/**\n\t\t * Change Selected Status of Items\n\t\t */\n\t\tthis._next = function(node) {\n\t\t\tvar count = node.children.length;\n\t\t\t//DEBUG console.log( \"__NEXT: co=\"+count+\" nbMatch=\"+this._bestMatches.length);\n\t\t\tif (this._bestMatches.length > 0)\n\t\t\t\tthis._goto(node, this._idxChoice < count - 1 ? this._idxChoice + 1 : -1);\n\t\t\t//DEBUG this._logStatus( \"NexT\" );\n\t\t};\n\t\tthis._previous = function(node) {\n\t\t\tvar count = node.children.length;\n\t\t\tvar selected = this._idxChoice > -1;\n\t\t\t//DEBUG console.log( \"__PREV: co=\"+count+\" nbMatch=\"+this._bestMatches.length);\n\t\t\tif (this._bestMatches.length > 0)\n\t\t\t\tthis._goto(node, selected ? this._idxChoice - 1 : count - 1);\n\t\t\t//DEBUG this._logStatus( \"PreV\" );\n\t\t};\n\t\t// Should not be used, highlights specific item without any checks!\n\t\tthis._goto = function(node, idx) {\n\t\t\tvar lis = node.children;\n\t\t\tvar selected = this._idxChoice > -1;\n\t\t\tif (selected) {\n\t\t\t\tlis[this._idxChoice].setAttribute(\"patt-selected\", \"false\");\n\t\t\t}\n\n\t\t\tthis._idxChoice = idx;\n\n\t\t\tif (idx > -1 && lis.length > 0) {\n\t\t\t\tlis[idx].setAttribute(\"patt-selected\", \"true\");\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * Abort pattern and undisplay.\n\t\t */\n\t\tthis._abortPattern = function(displayNode) {\n\t\t\tthis._state = \"VOID\";\n\t\t\tthis._bestChoices = [];\n\t\t\tthis._idxChoice = -1;\n\t\t\tthis._undisplay(displayNode);\n\t\t\tthis._template = undefined;\n\t\t};\n\t\t/**\n\t\t * Display popupNode at the cursor position in areaNode.\n\t\t */\n\t\tthis._display = function(areaNode, popupNode) {\n\t\t\tif (popupNode.style.display == 'none') {\n\t\t\t\t// Must get coordinate\n\t\t\t\t// Cursor coordinates within area + area coordinates + scroll\n\t\t\t\tvar coord = getCaretCoordinates(areaNode, areaNode.selectionEnd);\n\t\t\t\tvar styleSize = getComputedStyle(areaNode).getPropertyValue('font-size');\n\t\t\t\tvar fontSize = parseFloat(styleSize);\n\n\t\t\t\tpopupNode.style.left = (this._offLeft + areaNode.offsetLeft - areaNode.scrollLeft + coord.left) + 'px';\n\t\t\t\tpopupNode.style.top = (this._offTop + areaNode.offsetTop - areaNode.scrollTop + coord.top + fontSize * 2) + 'px';\n\t\t\t\tpopupNode.style.display = 'block';\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * Undisplay someNode\n\t\t */\n\t\tthis._undisplay = function(displayNode) {\n\t\t\tif (displayNode.style.display != 'none') {\n\t\t\t\tdisplayNode.style.display = 'none';\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Used for debug\n\t\t */\n\t\tthis._logStatus = function(msg) {\n\t\t\tconsole.log(\"__STATUS: \" + this._state + \":-\" + msg + \"- idx=\" + this._idxChoice);\n\t\t};\n\n\t};\n\t// **************************************************************************\n\t// ******************************************************************eventCbk\n\t// **************************************************************************\n\t/**\n\t * Disable the *effects* of ENTER / UP / DOWN / ESC when needed.\n\t * Set _hasInput to false.\n\t */\n\tCompletion.prototype.handleKeydown = function(event) {\n\t\t// key \n\t\tvar key = event.keyCode;\n\t\tthis._hasInput = false;\n\n\t\t//DEBUG console.log( \"__KEYDOWN (\"+key+\") hasI=\"+this._hasInput);\n\n\t\t// ENTER while selecting\n\t\tif ((this._state === \"PATTERN\" || this._state === \"SELECT\") && key === 13) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\t//return true;\n\t\t}\n\t\t// ESC while selecting\n\t\telse if ((this._state === \"PATTERN\" || this._state === \"SELECT\") && key === 27) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t}\n\t\t// UP/DOWN while a pattern is extracted\n\t\telse if ((key === 38 || key === 40) &&\n\t\t\t(this._state === \"PATTERN\" || this._state === \"SELECT\")) {\n\t\t\tevent.preventDefault();\n\t\t} else {\n\t\t\tif (this._widget._old_handler) {\nthis._widget._old_handler(event);\n}\n\t\t}\n\t};\n\t/**\n\t * Means that something has been added/deleted => set _hasInput\n\t */\n\tCompletion.prototype.handleInput = function(event) {\n\t\tthis._hasInput = true;\n\t\t//DEBUG console.log( \"__INPUT hasI=\"+this._hasInput );\n\t};\n\n\t/**\n\t * Set _lastChar, detects CTRL+SPACE.\n\t */\n\tCompletion.prototype.handleKeypress = function(event) {\n\t\tvar curPos = this._areaNode.selectionStart; // cursor position\n\t\tvar val = this._areaNode.value; // text in the area\n\t\t// key \n\t\tvar key = event.keyCode || event.which;\n\n\t\tthis._lastChar = String.fromCharCode(key);\n\t\t//DEBUG console.log( \"__KEYPRESS (\"+key+\") hasI=\"+this._hasInput+\" char=\"+this._lastChar );\n\t\t//DEBUG this._logStatus( \"KEYPRESS\" );\n\n\t\t// Detect Ctrl+Space\n\t\tif (this._triggerKeyMatcher(event) && this._state === \"VOID\") {\n\t\t\t//Find a proper Template\n\t\t\t// first from which we can extract a pattern\n\t\t\tif (this._template === undefined) {\n\t\t\t\t//DEBUG console.log(\"__SPACE : find a Template\" );\n\t\t\t\tvar idT, res;\n\t\t\t\tfor (idT = 0; idT < this._listTemp.length; idT++) {\n\t\t\t\t\tres = extractPattern(val, curPos, this._listTemp[idT]);\n\t\t\t\t\t//DEBUG console.log(\"  t=\"+this._listTemp[idT].pat+\" res=\"+res);\n\t\t\t\t\t// res is not undefined => good template candidate\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tthis._template = this._listTemp[idT];\n\t\t\t\t\t\tthis._state = \"PATTERN\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//DEBUG console.log(\"__SPACE : already a template\" );\n\t\t\t\tthis._state = \"PATTERN\";\n\t\t\t}\n\t\t}\n\t};\n\t/**\n\t * ESC -> abort; \n\t * Detect [ -> VOID switch to _state=PATTERN\n\t * PATTERN || SELECT : ENTER -> insertText\n\t *                     UP/DOWN -> previous/next\n\t *                     pattern.length > _minPatternLength -> display  \n\t */\n\tCompletion.prototype.handleKeyup = function(event) {\n\t\tvar curPos = this._areaNode.selectionStart; // cursor position\n\t\tvar val = this._areaNode.value; // text in the area\n\t\t// key a\n\t\tvar key = event.keyCode;\n\n\t\t//DEBUG console.log( \"__KEYUP (\"+key+\") hasI=\"+this._hasInput );\n\n\t\t// ESC\n\t\tif (key === 27) {\n\t\t\tthis._abortPattern(this._popNode);\n\t\t\t//DEBUG this._logStatus( \"\" );\n\t\t}\n\t\t// Check for every template\n\t\tif (this._hasInput && this._state === \"VOID\") {\n\t\t\t// check every template's pattern\n\t\t\tvar idT, template;\n\t\t\tfor (idT = 0; idT < this._listTemp.length; idT++) {\n\t\t\t\ttemplate = this._listTemp[idT];\n\t\t\t\tif (this._lastChar === template.pat[template.pos]) {\n\t\t\t\t\ttemplate.pos += 1;\n\t\t\t\t\t//DEBUG console.log( \"__CHECK : pat=\"+template.pat+\" pos=\"+template.pos );\n\t\t\t\t\t// Pattern totaly matched ?\n\t\t\t\t\tif (template.pos === template.pat.length) {\n\t\t\t\t\t\t//DEBUG console.log( \"__CHECK => found \"+template.pat );\n\t\t\t\t\t\tthis._state = \"PATTERN\";\n\t\t\t\t\t\tthis._template = template;\n\n\t\t\t\t\t\tbreak; // get out of loop\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttemplate.pos = 0;\n\t\t\t\t\t//DEBUG console.log( \"__CHECK : pat=\"+template.pat+\" pos=\"+template.pos );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// a pattern\n\t\telse if (this._state === \"PATTERN\" || this._state === \"SELECT\") {\n\t\t\t// Pattern below cursor : undefined if no pattern\n\t\t\tvar pattern = extractPattern(val, curPos, this._template);\n\t\t\tif (key === 13) { // ENTER\n\t\t\t\t//DEBUG console.log( \"KEY : Enter\" );\n\t\t\t\t// Choice made in the displayNode ?\n\t\t\t\tvar selected = this._idxChoice > -1 && this._idxChoice !== this._maxMatch;\n\t\t\t\t//DEBUG console.log( \"   > sel=\"+selected+\" len=\"+this._bestChoices.length );\n\t\t\t\tif (selected) {\n\t\t\t\t\t//DEBUG console.log( \"   > selected\" );\n\t\t\t\t\tvar temp = this._bestMatches[this._idxChoice];\n\t\t\t\t\tvar str = temp.str;\n\t\t\t\t\tif (this._template.field === \"body\") {\n\t\t\t\t\t\tstr = $tw.wiki.getTiddlerText(temp.title);\n\t\t\t\t\t}\n\t\t\t\t\tinsertInto(this._areaNode,\n\t\t\t\t\t\tstr,\n\t\t\t\t\t\tpattern.start, curPos, this._template);\n\t\t\t\t\t// save this new content\n\t\t\t\t\tthis._widget.saveChanges(this._areaNode.value);\n\t\t\t\t}\n\t\t\t\t// otherwise take the first choice (if exists)\n\t\t\t\telse if (this._bestMatches.length > 0) {\n\t\t\t\t\t//DEBUG console.log( \"   > take first one\" );\n\t\t\t\t\tvar temp = this._bestMatches[0];\n\t\t\t\t\tvar str = temp.str;\n\t\t\t\t\tif (this._template.field === \"body\") {\n\t\t\t\t\t\tstr = $tw.wiki.getTiddlerText(temp.title);\n\t\t\t\t\t}\n\t\t\t\t\tinsertInto(this._areaNode,\n\t\t\t\t\t\tstr,\n\t\t\t\t\t\tpattern.start, curPos, this._template);\n\t\t\t\t\t// save this new content\n\t\t\t\t\tthis._widget.saveChanges(this._areaNode.value);\n\t\t\t\t}\n\t\t\t\tthis._abortPattern(this._popNode);\n\t\t\t\t//DEBUG this._logStatus( \"\" );\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t} else if (key === 38 && this._hasInput === false) { // up\n\t\t\t\tthis._state = \"SELECT\";\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis._previous(this._popNode);\n\t\t\t\t//DEBUG this._logStatus( pattern.text );\n\t\t\t\t//event.stopPropagation();\n\t\t\t} else if (key === 40 && this._hasInput === false) { // down\n\t\t\t\tthis._state = \"SELECT\";\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis._next(this._popNode);\n\t\t\t\t//DEBUG this._logStatus( pattern.text );\n\t\t\t\t//event.stopPropagation();\n\t\t\t} else if (pattern) { // pattern changed by keypressed\n\t\t\t\tthis._idxChoice = -1;\n\t\t\t\t// log\n\t\t\t\t//DEBUG this._logStatus( pattern.text );\n\t\t\t\t// Popup with choices if pattern at least minPatLength letters long\n\t\t\t\tif (pattern.text.length > (this._minPatLength - 1)) {\n\t\t\t\t\t// compute listOptions from templateFilter\n\t\t\t\t\tvar allOptions;\n\t\t\t\t\tif (this._template)\n\t\t\t\t\t\tallOptions = this._widget.wiki.filterTiddlers(this._template.filter);\n\t\t\t\t\telse\n\t\t\t\t\t\tallOptions = this._widget.wiki.filterTiddlers(\"[all[tiddlers]]\");\n\t\t\t\t\tthis._findBestMatches(allOptions, pattern.text);\n\t\t\t\t\tthis._popNode.innerHTML = \"\";\n\t\t\t\t\t//console.log( \"BC \"+ this._pattern + \" => \" + choice );\n\t\t\t\t\tif (this._bestMatches.length > 0) {\n\t\t\t\t\t\tfor (var i = 0; i < this._bestMatches.length; i++) {\n\t\t\t\t\t\t\tthis._popNode.appendChild(\n\t\t\t\t\t\t\t\titemHTML(this._bestMatches[i].str,\n\t\t\t\t\t\t\t\t\tpattern.text));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._display(this._areaNode, this._popNode);\n\t\t\t\t\t} else { // no matches\n\t\t\t\t\t\tthis._state = \"PATTERN\";\n\t\t\t\t\t\tthis._undisplay(this._popNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { // no pattern detected\n\t\t\t\tthis._abortPattern(this._popNode);\n\t\t\t}\n\t\t}\n\t\t// to ensure that one MUST add an input (through onInput())\n\t\tthis._hasInput = false;\n\t};\n\t// **************************************************************************\n\t// ******************************************************** private functions\n\t// **************************************************************************\n\t/**\n\t * Create popup element.\n\t */\n\tvar createPopup = function(widget, node) {\n\t\t// Insert a special \"div\" element for poping up\n\t\t// Its 'display' property in 'style' control its visibility\n\t\tvar popupNode = widget.document.createElement(\"div\");\n\t\tpopupNode.setAttribute(\"style\", \"display:none; position: absolute;\");\n\t\tpopupNode.className = \"tc-block-dropdown ect-block-dropdown\";\n\t\t// Insert the element into the DOM\n\t\tnode.parentNode.insertBefore(popupNode, node.nextSibling);\n\t\t//CHECK the domNodes is a attribute of Widget [widget.js]\n\t\t//CHECK this.domNodes.push(popupNode);\n\n\t\treturn popupNode;\n\t};\n\t/**\n\t * Extract Pattern from text at a given position.\n\t *\n\t * Between previous template.pat (or '[[') and pos\n\t * \n\t * If no pattern -> undefined\n\t */\n\tvar extractPattern = function(text, pos, template) {\n\t\t// Detect previous and next ]]=>STOP or [[=>START\n\t\tvar sPat = template.pat ? template.pat : '[[';\n\t\tvar pos_prevOpen = text.lastIndexOf(sPat, pos);\n\t\tvar ePat = template.end ? template.end : ']]';\n\t\tvar pos_prevClosed = text.lastIndexOf(ePat, pos);\n\t\tvar pos_nextClosed = text.indexOf(ePat, pos);\n\t\t//DEBUG console.log(\"__CALC st=\"+sPat+\" -> en=\"+ePat );\n\t\t//DEBUG console.log(\"__CALC po=\"+pos_prevOpen+\" pc=\"+pos_prevClosed+\" nc=\"+pos_nextClosed+\" pos=\"+pos);\n\t\tpos_nextClosed = (pos_nextClosed >= 0) ? pos_nextClosed : pos;\n\n\t\tif ((pos_prevOpen >= 0) && // must be opened\n\t\t\t((pos_prevOpen > pos_prevClosed) || // not closed yet\n\t\t\t\t(pos_prevClosed === pos))) { // closed at cursor\n\t\t\t//DEBUG console.log(\"     pat=\"+text.slice( pos_prevOpen+sPat.length, pos) );\n\t\t\treturn {\n\t\t\t\ttext: text.slice(pos_prevOpen + sPat.length, pos),\n\t\t\t\tstart: pos_prevOpen,\n\t\t\t\tend: pos_nextClosed\n\t\t\t};\n\t\t}\n\t};\n\t/**\n\t * Controls how list items are generated.\n\t * Function that takes two parameters :\n\t *  - text : suggestion text\n\t *  - input : the user’s input\n\t * Returns : list item. \n\t * Generates list items with the user’s input highlighted via <mark>.\n\t */\n\tvar itemHTML = function(text, input) {\n\t\t// text si input === ''\n\t\t// otherwise, build RegExp that is global (g) and case insensitive (i)\n\t\t// to replace with <mark>$&</mark> where \"$&\" is the matched pattern\n\t\tvar html = input === '' ? text : text.replace(RegExp(regExpEscape(input.trim()), \"gi\"), \"<mark>$&</mark>\");\n\t\treturn create(\"li\", {\n\t\t\tinnerHTML: html,\n\t\t\t\"patt-selected\": \"false\"\n\t\t});\n\t};\n\t/**\n\t * Insert text into a textarea node, \n\t * enclosing in 'template.start..template.end'\n\t *\n\t * - posBefore : where the 'template.pat+pattern' starts\n\t * - posAfter : where the cursor currently is\n\t */\n\tvar insertInto = function(node, text, posBefore, posAfter, template) {\n\t\t//DEBUG console.log( \"__INSERT : \"+template.pattern+\":\"+template.filter+\":\"+template.mask+\":\"+template.field+\":\"+template.start+\":\"+template.end );\n\t\tvar val = node.value;\n\t\tvar sStart = template.start !== undefined ? template.start : '[[';\n\t\tvar sEnd = template.end !== undefined ? template.end : ']]';\n\t\tvar newVal = val.slice(0, posBefore) + sStart + text + sEnd + val.slice(posAfter);\n\t\t//console.log(\"__INSERT s=\"+sStart+\" e=\"+sEnd);\n\t\t//console.log (\"__INSERT pb=\"+posBefore+\" pa=\"+posAfter+\" txt=\"+text);\n\t\t//console.log( \"NEW VAL = \"+newVal );\n\t\t// WARN : Directly modifie domNode.value.\n\t\t// Not sure it does not short-circuit other update methods of the domNode....\n\t\t// i.e. could use widget.updateEditor(newVal) from edit-comptext widget.\n\t\t//      but how to be sure that cursor is well positionned ?\n\t\tnode.value = newVal;\n\n\t\t// if startOffset in Template, set cursor at beginning of inserted value,\n\t\t// with an Offset (usefull for aliasing links)\n\t\tif (template.startOffset) {\n\t\t\tlet cursorPos = posBefore + template.startOffset;\n\t\t\tnode.setSelectionRange(cursorPos, cursorPos);\n\t\t} else {\n\t\t\tnode.setSelectionRange(posBefore + text.length + sStart.length + sEnd.length, posBefore + text.length + sStart.length + sEnd.length);\n\t\t}\n\t};\n\t/**\n\t * Add an '\\' in front of -\\^$*+?.()|[]{}\n\t */\n\tvar regExpEscape = function(s) {\n\t\treturn s.replace(/[-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n\t};\n\t/**\n\t * Add an element in the DOM.\n\t */\n\tvar create = function(tag, o) {\n\t\tvar element = document.createElement(tag);\n\n\t\tfor (var i in o) {\n\t\t\tvar val = o[i];\n\n\t\t\tif (i === \"inside\") {\n\t\t\t\t$(val).appendChild(element);\n\t\t\t} else if (i === \"around\") {\n\t\t\t\tvar ref = $(val);\n\t\t\t\tref.parentNode.insertBefore(element, ref);\n\t\t\t\telement.appendChild(ref);\n\t\t\t} else if (i in element) {\n\t\t\t\telement[i] = val;\n\t\t\t} else {\n\t\t\t\telement.setAttribute(i, val);\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t};\n\n\n\texports.Completion = Completion;\n\n})();",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/completion.js",
            "module-type": "library",
            "modified": "20200625200624371",
            "created": "20200623204709537"
        },
        "$:/plugins/snowgoon88/edit-comptext/edit-comptext.css": {
            "text": "\n\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline macrocallblock\n\n/* The \\rules pragma at the top of the tiddler restricts the WikiText \n * to just allow macros and transclusion. This avoids mistakenly \n * triggering unwanted WikiText processing.\n * \n * MUST not save as text/css for macro to be processed\n*/\n\n.ect-block-dropdown li {\n    display: block;\n    padding: 4px 14px 4px 14px;\n    text-decoration: none;\n    color: <<colour tiddler-link-foreground>>; /*#5778d8;*/ \n    background: transparent;\n}\n.ect-block-dropdown li[patt-selected=\"true\"] {\n    color: <<colour tiddler-link-background>>; /*#ffffff; */\n    background-color: <<colour tiddler-link-foreground>>; /*#5778d8; */\n}\n.ect-block-dropdown li[patt-selected=\"true\"] mark {\n    background: hsl(86, 100%, 21%);\n    color: inherit;\n}\n\n",
            "type": "text/vnd.tiddlywiki",
            "title": "$:/plugins/snowgoon88/edit-comptext/edit-comptext.css",
            "tags": "$:/tags/Stylesheet"
        },
        "$:/plugins/snowgoon88/edit-comptext/readme": {
            "created": "20200918125920183",
            "text": "! This a custom version for testing only\n\n!! What ?\nThis plugin adds ''completion'' when editing the body of a tiddler.\n\n* Enter completion-mode by typing `[[` or `CTRL+SPACE`\n* A list of tiddlers with a title that matches the pattern between `[[` and cursor appears\n* `UP/DOWN` keys can select a tiddler, `ENTER` to validate\n* If there is only one match, `ENTER` selects it.\n* you can specify you own trigger pattern and the list of possible completions. See [[$:/plugins/snowgoon88/edit-comptext/usage]] for more details.\n* `NEW` : after completion, the cursor can be set inside the inserted text. This allows for easier creation of \"aliased links\" (try completion with `||` for example).\n* `NEW` : version 0.9.1 and higher, the default TW5 editor automatically has autocompletion as soon as the plugin is enabled (if TW5 version 5.1.22 or higher)\n\n!! To try it or get the latest news\nSee [[http://snowgoon88.github.io/TW5-extendedit]]\n\n!! Install \n\nTo add the plugin to your own TiddlyWiki5, just drag this link to the browser window:\n\n[[$:/plugins/snowgoon88/edit-comptext]]\n\nSometime (prior to TW5.1.22), a small configuration step is then needed\n\nin `$:/ControlPanel -> Advanced -> Editor Type -> text/vnd.tiddlywiki` you must chose `comptext` instead of `text`.\n\nReload and « voilà »...\n\nThis plugin is quite mature now :o)\n\n!! Old version\n\n* A version compatible with 5.0.8 to 5.1.11 : [[http://snowgoon88.github.io/TW5-extendedit/index_5.1.11.html]]\n\n!! Source code\nOn github [[https://github.com/snowgoon88/TW5-extendedit]]\n\nGet in touch : snowgoon88(AT)gmail(DOT)com\n",
            "title": "$:/plugins/snowgoon88/edit-comptext/readme",
            "modified": "20200918130011586"
        },
        "$:/plugins/snowgoon88/edit-comptext/usage": {
            "title": "$:/plugins/snowgoon88/edit-comptext/usage",
            "text": "''Important'' : be sure that in `$:/ControlPanel -> Advanced -> Editor Type -> text/vnd.tiddlywiki` you have chosen `comptext` instead of `text`.\n\nConfiguration of the edit-comptext plugin can be done through the tiddler [[$:/plugins/snowgoon88/edit-comptext/config]]. Use a JSON tiddler (do not forget to set the type to `application/json`. See some examples at [[$:/plugins/snowgoon88/edit-comptext/examples]]\n\nIn the `configuration` object you can set :\n\n* `caseSensitive`: `true`/`false` (is search case sensitive ?)\n* `maxMatch` : an `integer` (max number of match displayed)\n* `minPatLength` : an `integer` (minimal length of a pattern to trigger completion search)\n* `triggerKeyCombination ` : a `string` representing the key combination that triggers the autocompletion popup. To use modifier keys in your combination, use following conversions : `ctrl` -> `^`, `alt` -> `!`, `shift` -> `+`. Note: ` ` (literally a whitespace) represents the `space` key.\n\nIn the `template` array you can specify the various completion templates that will be used. Every template can have the following members.\n\n* `pattern` : `string` (pattern that triggers a completion, default \"[[\" )\n* `title` or `body`: `string` (the filter operators that gives the list of valid completions, default \"[all[tiddlers]!is[system]]\"). If you specify `body`, then the body of the tiddler will be inserted on selection.\n* `start` : `string` (when completion is chosen, start is put before the completion, default \"[[\")\n* `end` : `string` (when completion is chosen, end is put after the completion, default \"]]\")\n* `startOffset` : `interger` but OPTIONNAL. If provided, the cursor will be positionned `startOffsetè characters after the beginning of the completed text. This is useful to create aliased links using \"||\" as a trigger.\n\n!! Current body of Config Tiddler\n\n{{$:/plugins/snowgoon88/edit-comptext/config}}\n\n"
        }
    }
}